### Оконные функции и CTE
| **Задача** | **Инструменты** | **SQL запрос** |
| -------------------- | :--------------------- | :--------------------- |
|Для каждой записи в таблице user_actions с помощью оконных функций и FILTER посчитайте, сколько заказов сделал и сколько отменил каждый пользователь на момент совершения нового действия. Иными словами, для каждого пользователя в каждый момент времени посчитайте две накопительные суммы — числа оформленных и числа отменённых заказов. Если пользователь оформляет заказ, то число оформленных им заказов увеличивайте на 1, если отменяет — увеличивайте на 1 количество отмен. В результате у вас должны получиться три новые колонки с динамическими показателями, которые изменяются во времени с каждым новым действием пользователя.|`agg() FILTER (WHERE []) OVER([])`, |[Тык сюда](https://github.com/INLAE/SQL_karpov_course/blob/master/7.sql)|
|Отметьте в отдельной таблице тех курьеров, которые доставили в сентябре заказов больше, чем в среднем все курьеры. Сравните число заказов, доставленных каждым курьером, со средним значением в новом столбце. Если курьер доставил больше заказов, чем в среднем все курьеры, то в отдельном столбце с укажите число 1, в противном случае - 0. Результат отсортируйте по возрастанию id курьера.|`case when then end as`, `avg() over()`|[Тык сюда](https://github.com/INLAE/SQL_karpov_course/blob/master/6.sql)|
|Рассчитайте, сколько в среднем времени проходит между заказами каждого пользователя. Не считайте этот показатель для тех пользователей, которые за всё время оформили лишь один заказ. Полученное среднее значение (интервал) переведите в часы, а затем округлите до целого числа.|`EXTRACT(epoch FROM column)`, `avg`|[Тык сюда](https://github.com/INLAE/SQL_karpov_course/blob/master/5.sql)|
|Для каждого пользователя в таблице `user_actions` посчитайте порядковый номер каждого заказа. Отменённые заказы не учитывайте. Дополните запрос и с помощью оконной функции для каждого заказа каждого пользователя рассчитайте, сколько времени прошло с момента предыдущего заказа.  |`ROW_NUMBER`, `lag(column, 1)`,`OVER(PARTITION BY column ORDER BY column)`|[Тык сюда](https://github.com/INLAE/SQL_karpov_course/blob/master/4.sql)|
|Сначала на основе таблицы `orders` сформируйте новую таблицу с общим числом заказов по дням. При подсчёте числа заказов не учитывайте отменённые заказы (их можно определить по таблице `user_actions`). Затем поместите полученную таблицу в подзапрос и расчитайте накопительную сумму числа заказов. В результате такой операции значение накопительной суммы для последнего дня должно получиться равным общему числу заказов за весь период.|`WITH t1 AS(), t2 AS()`, `OVER(ORDER BY date)` |[Тык сюда](https://github.com/INLAE/SQL_karpov_course/blob/master/3.sql)|
|Примените оконные функции к таблице `products` и с помощью ранжирующих функций упорядочьте все товары по цене — от самых дорогих к самым дешёвым. Добавьте в таблицу следующие колонки: `product_number` с порядковым номером товара. `product_rank` с рангом товара с пропусками рангов. `product_dense_rank` с рангом товара без пропусков рангов.|`ROW_NUMBER`, `RANK`, `DENSE_RANK`| [Тык сюда](https://github.com/INLAE/SQL_karpov_course/blob/master/1.sql)|
|В таблице `products`. Проставьте цену самого дорогого товара - max_price. Затем для каждого товара посчитайте долю его цены в стоимости самого дорогого товара price / max_price. Полученные доли округлите до двух знаков после запятой. Результат отсортируйте сначала по убыванию цены товара, затем по возрастанию id товара.|`MAX()` `OVER()`, `ROUND()`|[Тык сюда](https://github.com/INLAE/SQL_karpov_course/blob/master/2.sql)|

### Визуализация на дашбордах в Redash
| **Задача** | **Dashboard** | **SQL запрос** |
| -------------------- | :--------------------- | :--------------------- |
|Для каждого дня, представленного в таблицах user actions и courier actions, рассчитайте следующие показатели: Число новых пользователей. Число новых курьеров. Общее число пользователей на текущий день. Общее число курьеров на текущий день. Показатели были выражены целыми числами. Результат должен быть отсортирован по возрастанию даты.|[визуализация](https://github.com/INLAE/SQL_karpov_course/blob/master/dashboards/1.png)|[в запрос](https://github.com/INLAE/SQL_karpov_course/blob/master/1_dashboard.sql)|
|     |      |     |
|     |      |     |
|     |      |     |
